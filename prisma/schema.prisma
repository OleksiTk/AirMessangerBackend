generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String  @unique
  phone_number   String?
  name      String?
  name_profile   String? @unique
  password  String?
  avatar String?
  last_name   String?
   // OAuth поля
  googleId  String @unique
// Відносини
  posts           Post[]
  refreshTokens   RefreshToken[]
  contacts        Contacts[]
  


  // Тут я зберігаю чати для користувача 
   chats    ChatParticipant[] // Чати користувача
  messages Message[]         // Повідомлення користувача
  
  createdAt       DateTime  @default(now())
}

model Chat {
  id        String   @id @default(uuid())
  name      String?  // Назва групового чату (опціонально)
  isGroup   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ChatParticipant[] // Учасники чату
  messages     Message[]         // Повідомлення
}

// Зв'язок користувачів з чатами (many-to-many)
model ChatParticipant {
  id     Int    @id @default(autoincrement())
  chatId String
  userId String

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [googleId], onDelete: Cascade)

  joinedAt DateTime @default(now())

  @@unique([chatId, userId]) // Один користувач не може бути двічі в одному чаті
}

// Повідомлення в чаті
model Message {
  id        Int      @id @default(autoincrement())
  chatId    String
  senderId  String
  content   String
  createdAt DateTime @default(now())
  isRead    Boolean  @default(false)
   fileUrl   String?  // URL файлу (/uploads/filename.jpg)
  fileName  String?  // Оригінальна назва файлу
  fileType  String?  // MIME type (image/png, application/pdf)
  fileSize  Int?     // Розмір в байтах
  chat   Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User @relation(fields: [senderId], references: [googleId], onDelete: Cascade)
}


// Залишилась для сумісності, але не потрібна для приватних чатів



model RefreshToken {
  id        Int     @id @default(autoincrement())
  token     String  @unique
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String
  author    User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
model Contacts {
  id        Int   @id @default(autoincrement()) // Використовуємо UUID як первинний ключ
  name_profile String  // Це буде UUID для контакту
  userId    String  // Це буде GoogleId користувача, унікальний для кожного користувача
  user      User    @relation(fields: [userId], references: [googleId])  // Встановлюємо відношення з User через googleId
}